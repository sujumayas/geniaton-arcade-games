<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bug Catcher</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    #gameContainer {
      width: 800px;
      height: 600px;
      background: linear-gradient(180deg, #000814 0%, #001122 100%);
    }

    #gameCanvas {
      width: 100%;
      height: 100%;
    }

    #bugs {
      color: #f0f;
      text-shadow: 0 0 10px #f0f;
    }

    .screen {
      padding: 30px 20px;
    }

    .screen h1 {
      font-size: 42px;
      margin-bottom: 15px;
    }

    .screen p {
      font-size: 16px;
      margin: 8px 0;
    }

    .screen button,
    .screen a {
      padding: 12px 25px;
      font-size: 15px;
      margin: 8px;
    }

    .name-input {
      width: 250px;
      font-size: 18px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="hud">
      <div id="score">Score: 0</div>
      <div id="bugs">üêõ Bugs: 0</div>
      <div id="distance">Distance: 0m</div>
    </div>

    <div id="startScreen" class="screen with-popup-leaderboard">
      <h1>üêõ BUG CATCHER üêõ</h1>
      <p>You're a developer in <span class="highlight">deep work mode</span>!</p>
      <p>Jump to <span class="highlight">avoid meetings</span> that break your focus.</p>
      <p>Catch <span class="highlight">bugs</span> flying by to increase your score!</p>
      <p><strong>Controls:</strong> Press <span class="highlight">SPACE</span> or <span class="highlight">UP ARROW</span> to jump | <span class="highlight">ESC</span> to pause</p>
      <p class="warning">‚ö†Ô∏è Speed increases as you progress! How long can you survive?</p>
      <button onclick="startGame()">START DEEP WORK</button>
      <button onclick="showHighscores()">VIEW HIGHSCORES</button>
    </div>

    <div id="highscorePopup" onclick="hideHighscores()">
      <h2>üèÜ TOP 10 LEADERBOARD</h2>
      <div id="leaderboard">
        <div id="leaderboardList"></div>
      </div>
      <p>Click anywhere to return</p>
    </div>

    <div id="pauseScreen" class="screen hidden">
      <h1>‚è∏Ô∏è PAUSED</h1>
      <p>Taking a break from deep work...</p>
      <p>Press <span class="highlight">ESC</span> to resume</p>
      <button onclick="resumeGame()">RESUME</button>
      <button onclick="restartGame()">RESTART</button>
    </div>

    <div id="gameOverScreen" class="screen hidden">
      <h1>üí• FOCUS BROKEN!</h1>
      <p>A meeting caught you! Your deep work session has ended.</p>
      <div id="finalStats">
        <p>Final Score: <span id="finalScore" class="highlight">0</span></p>
        <p>Bugs Caught: <span id="finalBugs" class="highlight">0</span> üêõ</p>
        <p>Distance: <span id="finalDistance" class="highlight">0</span>m</p>
      </div>
      <p>Enter your name for the leaderboard:</p>
      <input type="text" id="nameInput" class="name-input" placeholder="ENTER NAME" maxlength="20">
      <button onclick="saveScoreAndExit()">SAVE SCORE</button>
      <button onclick="exitToMenu()">SKIP</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game state
    let gameState = 'start'; // start, playing, paused, gameOver
    let animationId = null;
    let lastFrame = 0;

    // Game variables
    let score = 0;
    let bugsCaught = 0;
    let distance = 0;
    let gameSpeed = 3.5;  // Gentler starting speed
    const maxGameSpeed = 9;  // Reduced max speed for fairer gameplay
    let gravityRise = 0.6;  // Adjusted for lower jump
    let gravityFall = 0.8;  // Faster gravity when falling
    let maxFallSpeed = 15;  // Terminal velocity
    let jumpStrength = 14;  // Balanced - can clear obstacles comfortably (max height ~163px)
    let jumpHoldTime = 0;  // Track how long space is held
    const shortJumpStrength = 8;  // For quick taps
    const jumpHoldThreshold = 0.15;  // Time threshold to distinguish tap from hold (seconds)
    let isJumping = false;
    let jumpKeyPressed = false;  // Track if jump key is currently held
    let screenShake = 0;

    // Advanced jump mechanics
    let coyoteTime = 0;        // Grace period after leaving ground
    let coyoteTimeMax = 0.1;   // 0.1 seconds
    let jumpBuffer = 0;        // Remember jump input
    let jumpBufferMax = 0.1;   // 0.1 seconds

    // Player
    const player = {
      x: 100,
      y: 0,
      width: 40,
      height: 50,
      velocityY: 0,
      isOnGround: false
    };

    // Ground level
    const groundY = canvas.height - 80;

    // Obstacles (meetings)
    let obstacles = [];
    let obstacleTimer = 0;
    let obstacleInterval = 2.0; // seconds

    // Obstacle patterns for predictable but challenging gameplay
    const obstaclePatterns = [
      { interval: 2.2, count: 1, description: 'single' },       // Single obstacle - always safe to jump
      { interval: 2.5, count: 1, description: 'recovery' },     // Wide gap - recovery time
      { interval: 1.8, count: 2, gap: 2.5, description: 'double' }, // Two obstacles - jump both or run between
      { interval: 2.0, count: 1, description: 'single' },       // Single obstacle
      { interval: 2.8, count: 1, description: 'recovery' },     // Wide gap with potential bug
      { interval: 1.6, count: 2, gap: 2.0, description: 'quick-double' } // Quick succession
    ];
    let currentPattern = 0;
    let patternObstaclesSpawned = 0;
    let patternGapTimer = 0;

    // Collectibles (bugs)
    let bugs = [];
    let bugTimer = 0;
    let bugInterval = 1.5; // seconds

    // Particles
    let particles = [];

    // Audio context
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Sound effects
    function playSound(frequency, duration, type = 'sine', volume = 0.3) {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.frequency.value = frequency;
      oscillator.type = type;

      gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + duration);
    }

    function jumpSound() {
      playSound(600, 0.1, 'square', 0.2);
      setTimeout(() => playSound(800, 0.08, 'square', 0.15), 50);
    }

    function collectSound() {
      playSound(800, 0.1, 'sine', 0.25);
      setTimeout(() => playSound(1000, 0.1, 'sine', 0.25), 50);
      setTimeout(() => playSound(1200, 0.15, 'sine', 0.25), 100);
    }

    function crashSound() {
      playSound(150, 0.3, 'sawtooth', 0.4);
      setTimeout(() => playSound(100, 0.4, 'sawtooth', 0.4), 200);
    }

    // Particle class
    class Particle {
      constructor(x, y, color, size = 3) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6 - 2;
        this.life = 1;
        this.color = color;
        this.size = size;
      }

      update(delta) {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.3; // gravity
        this.life -= delta * 1.5;
      }

      draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // Obstacle class with visual telegraphing
    class Obstacle {
      constructor() {
        this.x = canvas.width;
        this.y = groundY - 55;  // Reduced height for better clearance
        this.width = 70;
        this.height = 55;  // Slightly shorter obstacle
        this.passed = false;
        this.spawnTime = 0;  // Track time since spawn for warning effects
      }

      update(delta) {
        this.x -= gameSpeed;
        this.spawnTime += delta;
      }

      isInWarningZone() {
        // Warning zone is the right 250px of screen
        return this.x >= canvas.width - 250;
      }

      draw() {
        const inWarningZone = this.isInWarningZone();

        // Draw warning indicator when obstacle is in warning zone
        if (inWarningZone) {
          // Pulsing warning line
          const pulse = Math.sin(this.spawnTime * 10) * 0.3 + 0.7;
          ctx.strokeStyle = `rgba(255, 0, 0, ${pulse * 0.5})`;
          ctx.lineWidth = 3;
          ctx.setLineDash([10, 5]);
          ctx.beginPath();
          ctx.moveTo(this.x, 0);
          ctx.lineTo(this.x, groundY);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Draw meeting icon/box with enhanced glow in warning zone
        ctx.fillStyle = '#f00';
        ctx.shadowColor = '#f00';
        ctx.shadowBlur = inWarningZone ? 25 : 15;  // Stronger glow in warning zone
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.shadowBlur = 0;

        // Draw text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('MEETING', this.x + this.width / 2, this.y + 20);
        ctx.fillText('üìÖ', this.x + this.width / 2, this.y + 40);
      }

      collidesWith(player) {
        // More forgiving collision with tolerance margins
        const margin = 5;  // 5px tolerance for better feel
        return player.x + margin < this.x + this.width &&
               player.x + player.width - margin > this.x &&
               player.y + margin < this.y + this.height &&
               player.y + player.height - margin > this.y;
      }
    }

    // Bug class with intelligent placement
    class Bug {
      constructor(obstacles) {
        this.x = canvas.width;
        this.width = 30;
        this.height = 30;
        this.collected = false;
        this.wobble = Math.random() * Math.PI * 2;

        // Intelligent height placement based on nearby obstacles
        this.y = this.calculateSafeHeight(obstacles);
      }

      calculateSafeHeight(obstacles) {
        // Define height zones based on actual jump capability
        // Jump strength 14 with gravity 0.6 gives max height ~163px
        const LOW_MIN = 40;   // Easy to reach
        const LOW_MAX = 85;   // Low jump
        const MID_MIN = 85;   // Medium difficulty
        const MID_MAX = 135;  // Mid-jump arc
        const HIGH_MIN = 135; // Challenging
        const HIGH_MAX = 160; // Requires perfect timing at jump peak

        // Check if any obstacle is nearby (within 200-500px ahead)
        const nearbyObstacle = obstacles.find(obs =>
          obs.x > this.x - 100 && obs.x < this.x + 500
        );

        let heightZone;

        if (nearbyObstacle) {
          // If obstacle nearby, only use MID or HIGH zones (safe to jump)
          heightZone = Math.random() < 0.6 ? 'MID' : 'HIGH';
        } else {
          // If no obstacle, can use any zone (including rewards for perfect timing)
          const rand = Math.random();
          if (rand < 0.3) heightZone = 'LOW';
          else if (rand < 0.7) heightZone = 'MID';
          else heightZone = 'HIGH';
        }

        // Calculate Y position based on chosen zone
        let height;
        switch(heightZone) {
          case 'LOW':
            height = LOW_MIN + Math.random() * (LOW_MAX - LOW_MIN);
            break;
          case 'MID':
            height = MID_MIN + Math.random() * (MID_MAX - MID_MIN);
            break;
          case 'HIGH':
            height = HIGH_MIN + Math.random() * (HIGH_MAX - HIGH_MIN);
            break;
        }

        return groundY - height;
      }

      update() {
        this.x -= gameSpeed;
        this.wobble += 0.1;
      }

      draw() {
        const wobbleY = Math.sin(this.wobble) * 5;

        // Enhanced glow when near player (magnetism feedback)
        const isNear = this.isNearPlayer(player);
        ctx.shadowColor = '#f0f';
        ctx.shadowBlur = isNear ? 30 : 20;  // Brighter glow when close
        ctx.font = '30px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Draw collection radius indicator when near (subtle)
        if (isNear) {
          ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 35, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.fillText('üêõ', this.x + this.width / 2, this.y + this.height / 2 + wobbleY);
        ctx.shadowBlur = 0;
      }

      collidesWith(player) {
        // Use distance-based collision with magnetism for more forgiving collection
        const bugCenterX = this.x + this.width / 2;
        const bugCenterY = this.y + this.height / 2;
        const playerCenterX = player.x + player.width / 2;
        const playerCenterY = player.y + player.height / 2;

        const distance = Math.sqrt(
          Math.pow(bugCenterX - playerCenterX, 2) +
          Math.pow(bugCenterY - playerCenterY, 2)
        );

        // Collection radius - more forgiving than exact AABB collision
        const collectionRadius = 35;  // Slightly larger than bug size for magnetism
        return distance < collectionRadius;
      }

      // Check if bug is near player for visual feedback
      isNearPlayer(player) {
        const bugCenterX = this.x + this.width / 2;
        const bugCenterY = this.y + this.height / 2;
        const playerCenterX = player.x + player.width / 2;
        const playerCenterY = player.y + player.height / 2;

        const distance = Math.sqrt(
          Math.pow(bugCenterX - playerCenterX, 2) +
          Math.pow(bugCenterY - playerCenterY, 2)
        );

        return distance < 50;  // Warning radius slightly larger than collection
      }
    }

    // Leaderboard functions
    function loadLeaderboard() {
      const data = localStorage.getItem('bugCatcherLeaderboard');
      return data ? JSON.parse(data) : [];
    }

    function saveLeaderboard(leaderboard) {
      localStorage.setItem('bugCatcherLeaderboard', JSON.stringify(leaderboard));
    }

    function addScoreToLeaderboard(name, score, bugs, distance) {
      const leaderboard = loadLeaderboard();

      leaderboard.push({
        name: name.trim().toUpperCase() || 'ANONYMOUS',
        score: score,
        bugs: bugs,
        distance: distance,
        date: new Date().toLocaleDateString()
      });

      // Sort by score descending
      leaderboard.sort((a, b) => b.score - a.score);

      // Keep only top 10
      const top10 = leaderboard.slice(0, 10);
      saveLeaderboard(top10);
    }

    function displayLeaderboard() {
      const leaderboard = loadLeaderboard();
      const listElement = document.getElementById('leaderboardList');

      if (leaderboard.length === 0) {
        listElement.innerHTML = '<p style="text-align: center; color: #0f0; opacity: 0.5;">No scores yet. Be the first!</p>';
        return;
      }

      listElement.innerHTML = leaderboard.map((entry, index) => {
        const rank = index + 1;
        const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
        const topClass = rank <= 3 ? 'top3' : '';

        return `
          <div class="leaderboard-entry ${topClass}">
            <span class="leaderboard-rank">${medal}</span>
            <span class="leaderboard-name">${entry.name}</span>
            <span class="leaderboard-score">${entry.score} pts</span>
          </div>
        `;
      }).join('');
    }

    function saveScoreAndExit() {
      const nameInput = document.getElementById('nameInput');
      const name = nameInput.value.trim();

      addScoreToLeaderboard(name, score, bugsCaught, distance);
      displayLeaderboard();
      nameInput.value = '';
      exitToMenu();
    }

    function exitToMenu() {
      // Hide all screens
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');

      // Show start screen
      document.getElementById('startScreen').classList.remove('hidden');

      // Reset game state
      gameState = 'start';
      resetGame();

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function resetGame() {
      score = 0;
      bugsCaught = 0;
      distance = 0;
      gameSpeed = 3.5;
      player.y = groundY - player.height;
      player.velocityY = 0;
      player.isOnGround = true;
      isJumping = false;
      jumpKeyPressed = false;
      jumpHoldTime = 0;
      coyoteTime = 0;
      jumpBuffer = 0;
      obstacles = [];
      bugs = [];
      particles = [];
      obstacleTimer = 0;
      bugTimer = 0;
      currentPattern = 0;
      patternObstaclesSpawned = 0;
      patternGapTimer = 0;
      screenShake = 0;
      updateHUD();
    }

    function updateHUD() {
      document.getElementById('score').textContent = 'Score: ' + score;
      document.getElementById('bugs').textContent = 'üêõ Bugs: ' + bugsCaught;
      document.getElementById('distance').textContent = 'Distance: ' + Math.floor(distance) + 'm';
    }

    function jump() {
      if (gameState === 'playing') {
        // Try to jump immediately if on ground or in coyote time
        if (player.isOnGround || coyoteTime > 0) {
          player.velocityY = -jumpStrength;
          player.isOnGround = false;
          isJumping = true;
          coyoteTime = 0;  // Use up coyote time
          jumpBuffer = 0;  // Clear buffer
          jumpSound();
        } else {
          // Store jump input for buffering
          jumpBuffer = jumpBufferMax;
        }
      }
    }

    function drawPlayer() {
      ctx.fillStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 15;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      ctx.shadowBlur = 0;

      // Draw developer symbol
      ctx.fillStyle = '#000';
      ctx.font = 'bold 20px Courier New';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('</>', player.x + player.width / 2, player.y + player.height / 2);
    }

    function drawGround() {
      // Ground line
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#0f0';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(canvas.width, groundY);
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Grid pattern on ground
      ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
      ctx.lineWidth = 1;
      const offset = (distance * gameSpeed) % 40;
      for (let i = -offset; i < canvas.width; i += 40) {
        ctx.beginPath();
        ctx.moveTo(i, groundY);
        ctx.lineTo(i, canvas.height);
        ctx.stroke();
      }
    }

    function drawBackground() {
      // Far background layer - slow parallax stars for depth (30% speed)
      ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
      const farOffset = (distance * gameSpeed * 0.3) % 100;
      for (let i = -farOffset; i < canvas.width; i += 100) {
        for (let j = 50; j < canvas.height - 100; j += 80) {
          ctx.fillRect(i, j, 2, 2);
        }
      }

      // Near background layer - grid lines synchronized with obstacles (100% speed)
      ctx.strokeStyle = 'rgba(0, 255, 0, 0.15)';
      ctx.lineWidth = 1;
      const nearOffset = (distance * gameSpeed) % 60;

      for (let i = -nearOffset; i < canvas.width; i += 60) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, groundY);
        ctx.stroke();
      }

      // Warning zone overlay on right side of screen
      const warningZoneX = canvas.width - 250;
      const gradient = ctx.createLinearGradient(warningZoneX, 0, canvas.width, 0);
      gradient.addColorStop(0, 'rgba(255, 100, 0, 0)');
      gradient.addColorStop(1, 'rgba(255, 100, 0, 0.05)');
      ctx.fillStyle = gradient;
      ctx.fillRect(warningZoneX, 0, 250, groundY);

      // Warning zone border
      ctx.strokeStyle = 'rgba(255, 100, 0, 0.2)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(warningZoneX, 0);
      ctx.lineTo(warningZoneX, groundY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function gameLoop(timestamp) {
      if (gameState !== 'playing') return;

      let delta = (timestamp - lastFrame) / 1000;
      lastFrame = timestamp;

      // Cap delta to prevent large jumps
      if (delta > 0.1) delta = 0.1;

      // Increase speed over time (gentler acceleration for fairer difficulty curve)
      if (gameSpeed < maxGameSpeed) {
        gameSpeed += 0.0003;  // Slower acceleration
        if (gameSpeed > maxGameSpeed) {
          gameSpeed = maxGameSpeed;
        }
      }

      // Increase score with distance
      distance += delta * 10;
      score = Math.floor(distance * 10 + bugsCaught * 100);
      updateHUD();

      // Screen shake
      let offsetX = 0, offsetY = 0;
      if (screenShake > 0) {
        offsetX = (Math.random() - 0.5) * screenShake * 30;
        offsetY = (Math.random() - 0.5) * screenShake * 30;
        screenShake -= delta * 3;
      }

      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.clearRect(-50, -50, canvas.width + 100, canvas.height + 100);

      // Draw background
      drawBackground();
      drawGround();

      // Update player physics
      if (!player.isOnGround) {
        // Apply variable gravity with floatiness at peak
        let currentGravity;
        if (player.velocityY >= -2 && player.velocityY <= 2) {
          // At jump peak - add floatiness for better control
          currentGravity = 0.3;
        } else if (player.velocityY < 0) {
          // Rising
          currentGravity = gravityRise;
          // If jump key released early, apply extra gravity to shorten jump
          if (!jumpKeyPressed && jumpHoldTime < jumpHoldThreshold) {
            currentGravity = gravityFall;
          }
        } else {
          // Falling
          currentGravity = gravityFall;
        }

        player.velocityY += currentGravity;

        // Apply terminal velocity
        if (player.velocityY > maxFallSpeed) {
          player.velocityY = maxFallSpeed;
        }

        player.y += player.velocityY;

        // Update coyote time (only if not jumping, i.e., walked off edge)
        if (!isJumping && coyoteTime > 0) {
          coyoteTime -= delta;
        }

        if (player.y >= groundY - player.height) {
          player.y = groundY - player.height;
          player.velocityY = 0;
          player.isOnGround = true;
          isJumping = false;

          // Apply buffered jump if player pressed jump before landing
          if (jumpBuffer > 0) {
            jump();
          }
        }
      } else {
        // Player is on ground - reset coyote time
        coyoteTime = coyoteTimeMax;
      }

      // Decrement jump buffer
      if (jumpBuffer > 0) {
        jumpBuffer -= delta;
      }

      // Track jump key hold time
      if (jumpKeyPressed && !player.isOnGround) {
        jumpHoldTime += delta;
      }

      drawPlayer();

      // Spawn obstacles using pattern system
      obstacleTimer += delta;

      const pattern = obstaclePatterns[currentPattern];
      const baseInterval = pattern.interval;
      // Adjust interval based on game speed (gets slightly faster but not too much)
      const adjustedInterval = Math.max(1.2, baseInterval - (gameSpeed - 3.5) * 0.08);

      if (pattern.count > 1 && patternObstaclesSpawned > 0) {
        // Multi-obstacle pattern: use gap timer for spacing between obstacles in the same pattern
        patternGapTimer += delta;
        if (patternGapTimer >= pattern.gap && patternObstaclesSpawned < pattern.count) {
          obstacles.push(new Obstacle());
          patternObstaclesSpawned++;
          patternGapTimer = 0;
        }

        // After all obstacles in pattern are spawned, wait for interval before next pattern
        if (patternObstaclesSpawned >= pattern.count && obstacleTimer >= adjustedInterval) {
          obstacleTimer = 0;
          currentPattern = (currentPattern + 1) % obstaclePatterns.length;
          patternObstaclesSpawned = 0;
        }
      } else {
        // Single obstacle pattern or first obstacle of multi-obstacle pattern
        if (obstacleTimer >= adjustedInterval) {
          obstacles.push(new Obstacle());
          patternObstaclesSpawned++;
          obstacleTimer = 0;
          patternGapTimer = 0;

          // If single obstacle pattern, move to next pattern immediately
          if (pattern.count === 1) {
            currentPattern = (currentPattern + 1) % obstaclePatterns.length;
            patternObstaclesSpawned = 0;
          }
        }
      }

      // Update and draw obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        obstacle.update(delta);
        obstacle.draw();

        // Check collision
        if (obstacle.collidesWith(player)) {
          gameOver();
          return;
        }

        // Award points for passing obstacle
        if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
          obstacle.passed = true;
          score += 50;
        }

        // Remove off-screen obstacles
        if (obstacle.x + obstacle.width < 0) {
          obstacles.splice(i, 1);
        }
      }

      // Spawn bugs with intelligent placement
      bugTimer += delta;
      if (bugTimer >= bugInterval) {
        bugs.push(new Bug(obstacles));  // Pass obstacles for intelligent placement
        bugTimer = 0;
        bugInterval = Math.max(0.8, 1.5 - (gameSpeed - 3.5) * 0.05);  // Adjusted for new speed range
      }

      // Update and draw bugs
      for (let i = bugs.length - 1; i >= 0; i--) {
        const bug = bugs[i];
        bug.update();
        bug.draw();

        // Check collision
        if (!bug.collected && bug.collidesWith(player)) {
          bug.collected = true;
          bugsCaught++;
          score += 100;
          collectSound();

          // Create particles
          for (let j = 0; j < 20; j++) {
            particles.push(new Particle(bug.x + bug.width / 2, bug.y + bug.height / 2, '#f0f', 4));
          }

          bugs.splice(i, 1);
        }

        // Remove off-screen bugs
        if (bug.x + bug.width < 0) {
          bugs.splice(i, 1);
        }
      }

      // Update and draw particles
      particles = particles.filter(p => {
        p.update(delta);
        p.draw();
        return p.life > 0;
      });

      ctx.restore();

      animationId = requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.getElementById('startScreen').classList.add('hidden');
      resetGame();
      gameState = 'playing';
      lastFrame = performance.now();
      animationId = requestAnimationFrame(gameLoop);
    }

    function pauseGame() {
      if (gameState === 'playing') {
        gameState = 'paused';
        document.getElementById('pauseScreen').classList.remove('hidden');
      }
    }

    function resumeGame() {
      if (gameState === 'paused') {
        gameState = 'playing';
        document.getElementById('pauseScreen').classList.add('hidden');
        lastFrame = performance.now();
        animationId = requestAnimationFrame(gameLoop);
      }
    }

    function gameOver() {
      gameState = 'gameOver';
      crashSound();
      screenShake = 1;

      // Create explosion particles
      for (let i = 0; i < 50; i++) {
        particles.push(new Particle(player.x + player.width / 2, player.y + player.height / 2, ['#f00', '#ff0', '#f0f'][Math.floor(Math.random() * 3)], 5));
      }

      // Update final stats
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalBugs').textContent = bugsCaught;
      document.getElementById('finalDistance').textContent = Math.floor(distance);
      document.getElementById('gameOverScreen').classList.remove('hidden');

      // Focus on name input
      setTimeout(() => {
        document.getElementById('nameInput').focus();
      }, 100);
    }

    function restartGame() {
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      startGame();
    }

    // Event listeners
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (gameState === 'playing') {
          pauseGame();
        } else if (gameState === 'paused') {
          resumeGame();
        }
        return;
      }

      if (e.key === ' ' || e.key === 'ArrowUp') {
        e.preventDefault();
        if (!jumpKeyPressed) {  // Only trigger on initial press
          jumpKeyPressed = true;
          jumpHoldTime = 0;
          jump();
        }
      }

      // Submit score with Enter key
      if (e.key === 'Enter' && gameState === 'gameOver') {
        saveScoreAndExit();
      }
    });

    // Track key release for variable jump height
    document.addEventListener('keyup', (e) => {
      if (e.key === ' ' || e.key === 'ArrowUp') {
        jumpKeyPressed = false;
      }
    });

    // Allow Enter key to submit name
    document.getElementById('nameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        saveScoreAndExit();
      }
    });

    // Initialize leaderboard on page load
    displayLeaderboard();

    // Initial player position
    player.y = groundY - player.height;

    // Highscore popup functions
    function showHighscores() {
      displayLeaderboard();
      document.getElementById('highscorePopup').classList.add('show');
    }

    function hideHighscores() {
      document.getElementById('highscorePopup').classList.remove('show');
    }
  </script>
</body>
</html>
