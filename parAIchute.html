<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Prompt Shooter</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    #gameContainer {
      width: 800px;
      height: 600px;
    }

    canvas {
      background: radial-gradient(ellipse at center, #111 0%, #000 100%);
    }

    .screen {
      padding: 30px 20px;
    }

    .screen h1 {
      font-size: 42px;
      margin-bottom: 15px;
    }

    .screen p {
      font-size: 16px;
      margin: 8px 0;
    }

    .screen button,
    .screen a {
      padding: 12px 25px;
      font-size: 15px;
      margin: 8px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="typedWord"></div>
    <div id="hud">
      <div id="level">Level 1</div>
      <div id="score">Score: 0</div>
      <div id="lives">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
    </div>
    <div id="combo" class="hidden"></div>

    <div id="startScreen" class="screen with-popup-leaderboard">
      <h1>üéØ PROMPT SHOOTER</h1>
      <p>Type GenAI terms to shoot falling words before they hit the ground!</p>
      <p>Type the word and press ENTER to fire. Match words exactly (case-sensitive).</p>
      <p><strong>Controls:</strong> Type to aim, ENTER to shoot, ESC to pause</p>
      <p>Complete all 20 levels to win! Levels 11+ are LEGENDARY difficulty!</p>
      <button onclick="startGame()">START GAME</button>
      <button onclick="showHighscores()">VIEW HIGHSCORES</button>
    </div>

    <div id="highscorePopup" onclick="hideHighscores()">
      <h2>üèÜ TOP 10 LEADERBOARD</h2>
      <div id="leaderboard">
        <div id="leaderboardList"></div>
      </div>
      <p>Click anywhere to return</p>
    </div>

    <div id="pauseScreen" class="screen hidden">
      <h1>‚è∏Ô∏è PAUSED</h1>
      <p>Press ESC to resume</p>
      <button onclick="resumeGame()">RESUME</button>
      <button onclick="restartGame()">RESTART</button>
    </div>

    <div id="gameOverScreen" class="screen hidden">
      <h1>üíÄ GAME OVER</h1>
      <p id="finalScore"></p>
      <p>You made it to Level <span id="finalLevel"></span></p>
      <input type="text" id="gameOverNameInput" class="name-input" placeholder="Enter your name (optional)" maxlength="20">
      <button onclick="saveScoreAndExit('gameOver')">CONTINUE</button>
    </div>

    <div id="winScreen" class="screen hidden">
      <h1>üèÜ VICTORY!</h1>
      <p>You've mastered all GenAI terms!</p>
      <p id="winScore"></p>
      <input type="text" id="winNameInput" class="name-input" placeholder="Enter your name (optional)" maxlength="20">
      <button onclick="saveScoreAndExit('win')">CONTINUE</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const typedDisplay = document.getElementById('typedWord');
    const levelDisplay = document.getElementById('level');
    const scoreDisplay = document.getElementById('score');
    const livesDisplay = document.getElementById('lives');
    const comboDisplay = document.getElementById('combo');

    const canonX = canvas.width / 2;
    const canonY = canvas.height - 30;

    // Base levels 1-10 (original difficulty)
    const baseLevels = [
      ["prompt", "token", "LLM", "embedding"],
      ["vector", "inference", "chatbot", "alignment", "hallucination"],
      ["context", "multimodal", "GPT", "prompting", "temperature"],
      ["zero-shot", "fine-tune", "openAI", "transformer", "few-shot"],
      ["decoder", "encoder", "layer", "attention"],
      ["chain", "LangChain", "RAG", "cohere", "claude"],
      ["replicate", "API", "autogen", "pipeline", "dataset"],
      ["bias", "output", "training", "json", "tokenizer"],
      ["agent", "scratchpad", "RLHF", "retrieval"],
      ["meta", "mistral", "groq", "llama", "gemini"]
    ];

    // Additional words for levels 11-20 (progressive difficulty)
    const additionalWords = [
      "latency", "sampling", "perplexity", "beam-search", "top-k",
      "nucleus", "parameters", "weights", "gradient", "backprop"
    ];

    // Generate word pool for a given level
    function getLevelWords(levelNum) {
      if (levelNum < 10) {
        // Levels 1-10: Use base levels as-is
        return baseLevels[levelNum];
      } else {
        // Levels 11-20: Sequential growth (each level adds 1 word to previous level's pool)
        let pool = [...baseLevels[9]]; // Start with level 10's words

        // Add words sequentially up to current level
        for (let i = 0; i <= levelNum - 10; i++) {
          pool.push(additionalWords[i]);
        }

        return pool;
      }
    }

    let level = 0;
    let words = [];
    let activeBullets = [];
    let particles = [];
    let typed = "";
    let lastFrame = 0;
    let gameState = "start"; // start, playing, paused, gameOver, win
    let animationId = null;
    let lives = 5;
    let score = 0;
    let combo = 0;
    let comboTimer = 0;
    let screenShake = 0;
    let targetWord = null;

    // Glitch effect variables for levels 10+
    let glitchTimer = 0;
    let warningTimer = 0;
    let currentWarning = null;
    let warningDuration = 0;
    let colorFlickerTimer = 0;
    let scanlineOffset = 0;
    let baseShakeAmount = 0;
    let impactShakeTimer = 0;

    // Audio context for sound effects
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Leaderboard functions
    function loadLeaderboard() {
      const data = localStorage.getItem('promptShooterLeaderboard');
      return data ? JSON.parse(data) : [];
    }

    function saveLeaderboard(leaderboard) {
      localStorage.setItem('promptShooterLeaderboard', JSON.stringify(leaderboard));
    }

    function addScoreToLeaderboard(name, score, level) {
      const leaderboard = loadLeaderboard();

      // Check if score qualifies for top 10
      if (leaderboard.length >= 10) {
        const lowestScore = leaderboard[leaderboard.length - 1].score;
        if (score <= lowestScore) {
          // Score doesn't make top 10, don't save
          return false;
        }
      }

      // Add new score
      leaderboard.push({
        name: name.trim(),
        score: score,
        level: level,
        date: new Date().toLocaleDateString()
      });

      // Sort by score descending
      leaderboard.sort((a, b) => b.score - a.score);

      // Keep only top 10
      const top10 = leaderboard.slice(0, 10);
      saveLeaderboard(top10);

      return true;
    }

    function displayLeaderboard() {
      const leaderboard = loadLeaderboard();
      const listElement = document.getElementById('leaderboardList');

      if (leaderboard.length === 0) {
        listElement.innerHTML = '<p style="text-align: center; color: #0f0; opacity: 0.5;">No scores yet. Be the first!</p>';
        return;
      }

      listElement.innerHTML = leaderboard.map((entry, index) => {
        const rank = index + 1;
        const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}.`;
        const topClass = rank <= 3 ? 'top3' : '';

        return `
          <div class="leaderboard-entry ${topClass}">
            <span class="leaderboard-rank">${medal}</span>
            <span class="leaderboard-name">${entry.name}</span>
            <span class="leaderboard-score">${entry.score}</span>
          </div>
        `;
      }).join('');
    }

    function saveScoreAndExit(screenType) {
      const nameInput = screenType === 'win'
        ? document.getElementById('winNameInput')
        : document.getElementById('gameOverNameInput');

      const name = nameInput.value.trim();

      // Only save if name is provided
      if (name !== '') {
        addScoreToLeaderboard(name, score, level + 1);
      }

      displayLeaderboard();
      nameInput.value = '';
      exitToMenu();
    }

    function exitToMenu() {
      // Hide all game screens
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('winScreen').classList.add('hidden');

      // Show start screen
      document.getElementById('startScreen').classList.remove('hidden');

      // Reset game state
      gameState = "start";
      words = [];
      activeBullets = [];
      particles = [];
      targetWord = null;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function playSound(frequency, duration, type = 'sine') {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.frequency.value = frequency;
      oscillator.type = type;

      gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + duration);
    }

    function shootSound() {
      playSound(800, 0.1, 'square');
    }

    function hitSound() {
      playSound(1200, 0.15, 'sine');
      setTimeout(() => playSound(1000, 0.1, 'sine'), 50);
    }

    function missSound() {
      playSound(200, 0.3, 'sawtooth');
    }

    function gameOverSound() {
      playSound(400, 0.2, 'sawtooth');
      setTimeout(() => playSound(300, 0.2, 'sawtooth'), 150);
      setTimeout(() => playSound(200, 0.4, 'sawtooth'), 300);
    }

    // ===== GLITCH EFFECTS FOR LEVELS 10+ =====

    // Calculate glitch intensity based on level (0 for levels < 10)
    function getGlitchIntensity() {
      if (level < 10) return 0;

      // Progressive intensity
      if (level < 12) return 0.3;  // Level 10-11: Mild
      if (level < 15) return 0.5;  // Level 12-14: Moderate
      if (level < 18) return 0.7;  // Level 15-17: Heavy
      return 1.0;                   // Level 18-20: Extreme
    }

    // Draw scanlines effect
    function drawScanlines(intensity) {
      const lineCount = Math.floor(10 * intensity);
      ctx.strokeStyle = `rgba(0, 255, 0, ${0.1 * intensity})`;
      ctx.lineWidth = 2;

      for (let i = 0; i < lineCount; i++) {
        const y = (scanlineOffset + i * 60) % canvas.height;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    // Draw static/noise overlay
    function drawStatic(intensity) {
      if (Math.random() < 0.95) return; // Only show occasionally

      const pixels = ctx.createImageData(canvas.width, canvas.height);
      const opacity = 0.15 * intensity;

      for (let i = 0; i < pixels.data.length; i += 4) {
        if (Math.random() < 0.1 * intensity) {
          const val = Math.random() * 255;
          pixels.data[i] = val;     // R
          pixels.data[i + 1] = val; // G
          pixels.data[i + 2] = val; // B
          pixels.data[i + 3] = opacity * 255; // A
        }
      }

      ctx.putImageData(pixels, 0, 0);
    }

    // Get pulsing background color based on intensity
    function getPulsingColor(intensity, time) {
      if (intensity === 0) return null;

      const pulse = Math.sin(time * 3) * 0.5 + 0.5; // 0 to 1
      const r = Math.floor(17 + (255 - 17) * pulse * intensity);
      const g = Math.floor(17 - 17 * pulse * intensity);
      const b = 0;

      return `rgb(${r}, ${g}, ${b})`;
    }

    // Draw warning text
    function drawWarning() {
      if (!currentWarning) return;

      ctx.save();
      ctx.font = "bold 24px Courier New";
      ctx.textAlign = "center";

      // Flashing effect
      const flash = Math.sin(Date.now() / 100) > 0;
      ctx.fillStyle = flash ? "#f00" : "#ff0";
      ctx.shadowColor = flash ? "#f00" : "#ff0";
      ctx.shadowBlur = 30;

      // Glitch effect on text position
      const glitchX = (Math.random() - 0.5) * 10;
      const glitchY = (Math.random() - 0.5) * 5;

      ctx.fillText(currentWarning, canvas.width / 2 + glitchX, 60 + glitchY);
      ctx.restore();
    }

    // Update glitch effects
    function updateGlitchEffects(delta) {
      const intensity = getGlitchIntensity();
      if (intensity === 0) return;

      // Update scanline animation
      scanlineOffset += 50 * delta * intensity;
      if (scanlineOffset > canvas.height) scanlineOffset = 0;

      // Update color flicker timer
      colorFlickerTimer += delta;

      // Update warning text
      warningTimer -= delta;
      if (warningTimer <= 0 && currentWarning === null) {
        // Spawn new warning
        const warnings = [
          "‚ö†Ô∏è SYSTEM OVERLOAD",
          "‚ö†Ô∏è CRITICAL ERROR",
          "‚ö†Ô∏è DEFENSE BREACH",
          "‚ö†Ô∏è CORE MELTDOWN",
          "‚ö†Ô∏è SHUTDOWN IMMINENT"
        ];
        currentWarning = warnings[Math.floor(Math.random() * warnings.length)];
        warningDuration = 1.5; // Show for 1.5 seconds

        // Random interval based on intensity
        warningTimer = (3 - 2 * intensity) + Math.random() * 2;
      }

      if (currentWarning !== null) {
        warningDuration -= delta;
        if (warningDuration <= 0) {
          currentWarning = null;
        }
      }

      // Update base screen shake
      baseShakeAmount = 0.1 * intensity;

      // Periodic impact shakes
      impactShakeTimer -= delta;
      if (impactShakeTimer <= 0) {
        screenShake = Math.max(screenShake, 0.3 * intensity);
        impactShakeTimer = 2 - intensity; // More frequent at higher intensity
      }
    }

    // Draw all glitch effects
    function drawGlitchEffects() {
      const intensity = getGlitchIntensity();
      if (intensity === 0) return;

      // Pulsing background color
      const bgColor = getPulsingColor(intensity, colorFlickerTimer);
      if (bgColor && Math.random() < 0.8) { // Occasional normal background
        ctx.fillStyle = bgColor;
        ctx.globalAlpha = 0.3 * intensity;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
      }

      // Random color inversion flash
      if (Math.random() < 0.02 * intensity) {
        ctx.globalCompositeOperation = 'difference';
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
      }

      // Scanlines
      drawScanlines(intensity);

      // Static overlay
      drawStatic(intensity);

      // Warning text (drawn last, on top)
      drawWarning();
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 200;
        this.vy = (Math.random() - 0.5) * 200;
        this.life = 1;
        this.color = color;
        this.size = Math.random() * 3 + 2;
      }

      update(delta) {
        this.x += this.vx * delta;
        this.y += this.vy * delta;
        this.vy += 200 * delta; // gravity
        this.life -= delta * 2;
      }

      draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    class FallingWord {
      constructor(word, yOffset = 0) {
        this.word = word;
        this.y = -50 + yOffset; // Support staggered spawning
        this.speed = 30 + Math.random() * 30 + (level * 5); // Speed increases per level

        // Measure word width first
        this.width = ctx.measureText(word).width;

        // Calculate safe x position to keep entire word visible
        // Add margin of 20px on each side
        const margin = 20;
        const minX = margin;
        const maxX = canvas.width - this.width - margin;

        // Try to find a position that doesn't overlap with existing words
        let attempts = 0;
        let validPosition = false;

        while (!validPosition && attempts < 50) {
          this.x = Math.random() * (maxX - minX) + minX;
          validPosition = this.checkSpacing();
          attempts++;
        }

        // If we couldn't find a good position after 50 attempts, use the last one anyway
      }

      checkSpacing() {
        // Check if this word overlaps with existing words
        const minSpacing = 80; // Minimum horizontal distance between words

        for (let word of words) {
          const horizontalDistance = Math.abs(this.x - word.x);
          const verticalDistance = Math.abs(this.y - word.y);

          // Only check spacing if words are vertically close
          if (verticalDistance < 100 && horizontalDistance < minSpacing + this.width) {
            return false; // Too close
          }
        }
        return true; // Spacing is good
      }

      update(delta) {
        this.y += this.speed * delta;
      }

      draw() {
        // Highlight if this is the target word
        if (targetWord && targetWord.word === this.word) {
          ctx.fillStyle = "#ff0";
          ctx.shadowColor = "#ff0";
          ctx.shadowBlur = 20;
        } else {
          ctx.fillStyle = "#0f0";
          ctx.shadowColor = "#0f0";
          ctx.shadowBlur = 10;
        }
        ctx.fillText(this.word, this.x, this.y);
        ctx.shadowBlur = 0;
      }
    }

    // Calculate intercept point for predictive aiming
    function calculateInterceptPoint(word) {
      const bulletSpeed = 500;
      const wordX = word.x;
      const wordY = word.y;
      const wordVY = word.speed; // Word falling speed

      // Solve quadratic equation for intercept time
      // Distance equation: sqrt((wordX - canonX)¬≤ + (wordY + wordVY*t - canonY)¬≤) = bulletSpeed * t
      const dx = wordX - canonX;
      const dy = wordY - canonY;

      // Coefficients for quadratic equation: a*t¬≤ + b*t + c = 0
      const a = wordVY * wordVY - bulletSpeed * bulletSpeed;
      const b = 2 * dy * wordVY;
      const c = dx * dx + dy * dy;

      // Calculate discriminant
      const discriminant = b * b - 4 * a * c;

      // If no real solution, aim at current position (shouldn't happen with our setup)
      if (discriminant < 0) {
        return { x: wordX, y: wordY };
      }

      // Solve for time (take positive solution that represents future intercept)
      const sqrtDisc = Math.sqrt(discriminant);
      const t1 = (-b + sqrtDisc) / (2 * a);
      const t2 = (-b - sqrtDisc) / (2 * a);

      // Choose the smaller positive time value
      let t;
      if (t1 > 0 && t2 > 0) {
        t = Math.min(t1, t2);
      } else if (t1 > 0) {
        t = t1;
      } else if (t2 > 0) {
        t = t2;
      } else {
        // No positive solution, aim at current position
        return { x: wordX, y: wordY };
      }

      // Calculate intercept point
      const interceptX = wordX; // Word doesn't move horizontally
      const interceptY = wordY + wordVY * t;

      return { x: interceptX, y: interceptY };
    }

    class Bullet {
      constructor(word) {
        this.x = canonX;
        this.y = canonY;
        this.word = word.word;

        // Calculate intercept point using predictive aiming
        const intercept = calculateInterceptPoint(word);
        this.targetX = intercept.x;
        this.targetY = intercept.y;

        // Calculate trajectory to intercept point
        const dx = intercept.x - canonX;
        const dy = intercept.y - canonY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const speed = 500;

        this.vx = (dx / distance) * speed;
        this.vy = (dy / distance) * speed;
      }

      update(delta) {
        this.x += this.vx * delta;
        this.y += this.vy * delta;
      }

      draw() {
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.vx * 0.02, this.y - this.vy * 0.02);
        ctx.strokeStyle = "#f0f";
        ctx.lineWidth = 3;
        ctx.shadowColor = "#f0f";
        ctx.shadowBlur = 10;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    // Determine batch size based on level for difficulty curve
    function getBatchSize(levelNum) {
      if (levelNum < 5) return 2;      // Levels 1-5: 2 words per batch
      if (levelNum < 10) return 3;     // Levels 6-10: 3 words per batch
      if (levelNum < 15) return 4;     // Levels 11-15: 4 words per batch
      return 5;                         // Levels 16-20: 5 words per batch
    }

    // Determine spawn delay between batches
    function getSpawnDelay(levelNum) {
      if (levelNum < 10) return 800;   // Levels 1-10: 0.8 second delay
      if (levelNum < 15) return 600;   // Levels 11-15: 0.6 second delay
      return 400;                       // Levels 16-20: 0.4 second delay (faster = harder)
    }

    // Spawn a single batch of words with staggered Y positions
    function spawnBatch(batch) {
      batch.forEach((word, index) => {
        const yOffset = -index * 60; // Stagger vertically (60px spacing)
        words.push(new FallingWord(word, yOffset));
      });
    }

    // Spawn entire level in batches with delays
    function spawnLevel() {
      const levelWords = getLevelWords(level);
      const batchSize = getBatchSize(level);
      const spawnDelay = getSpawnDelay(level);

      // Split words into batches
      for (let i = 0; i < levelWords.length; i += batchSize) {
        const batch = levelWords.slice(i, i + batchSize);
        const delay = (i / batchSize) * spawnDelay;

        setTimeout(() => {
          spawnBatch(batch);
        }, delay);
      }

      levelDisplay.textContent = "Level " + (level + 1) + "/20";
    }

    function updateHUD() {
      scoreDisplay.textContent = "Score: " + score;
      const hearts = "‚ù§Ô∏è".repeat(Math.max(0, lives));
      livesDisplay.textContent = "Lives: " + hearts;

      if (combo > 1) {
        comboDisplay.textContent = `${combo}x COMBO!`;
        comboDisplay.classList.remove('hidden');
      } else {
        comboDisplay.classList.add('hidden');
      }
    }

    function loseLife() {
      lives--;
      screenShake = 0.5;
      missSound();
      updateHUD();

      if (lives <= 0) {
        gameOver();
      }
    }

    function addScore(points) {
      score += points * Math.max(1, combo);
      comboTimer = 2; // Reset combo timer
      updateHUD();
    }

    function gameLoop(timestamp) {
      if (gameState !== "playing") return;

      let delta = (timestamp - lastFrame) / 1000;
      lastFrame = timestamp;

      // Update combo timer
      if (combo > 1) {
        comboTimer -= delta;
        if (comboTimer <= 0) {
          combo = 0;
          updateHUD();
        }
      }

      // Update glitch effects for levels 10+
      updateGlitchEffects(delta);

      // Enhanced screen shake (includes base shake from glitch intensity)
      let offsetX = 0, offsetY = 0;
      const totalShake = screenShake + baseShakeAmount;
      if (totalShake > 0) {
        offsetX = (Math.random() - 0.5) * totalShake * 20;
        offsetY = (Math.random() - 0.5) * totalShake * 20;
        screenShake -= delta * 2;
        if (screenShake < 0) screenShake = 0;
      }

      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.clearRect(-10, -10, canvas.width + 20, canvas.height + 20);

      // Draw aiming line to target word
      if (targetWord) {
        ctx.beginPath();
        ctx.moveTo(canonX, canonY);
        ctx.lineTo(targetWord.x, targetWord.y);
        ctx.strokeStyle = "rgba(255, 255, 0, 0.3)";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw canon
      ctx.fillStyle = "#0f0";
      ctx.shadowColor = "#0f0";
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(canonX, canonY, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Update and draw words
      for (let i = words.length - 1; i >= 0; i--) {
        let w = words[i];
        w.update(delta);
        w.draw();

        // Check if word hit bottom
        if (w.y > canvas.height) {
          words.splice(i, 1);
          combo = 0;
          loseLife();
        }
      }

      // Update and draw bullets
      for (let b of activeBullets) {
        b.update(delta);
        b.draw();
      }

      // Update and draw particles
      particles = particles.filter(p => {
        p.update(delta);
        p.draw();
        return p.life > 0;
      });

      // Bullet collision
      activeBullets = activeBullets.filter(b => {
        for (let i = 0; i < words.length; i++) {
          let w = words[i];
          const dist = Math.sqrt((b.x - w.x) ** 2 + (b.y - w.y) ** 2);
          if (dist < 40 && b.word === w.word) {
            // Hit!
            words.splice(i, 1);
            combo++;
            addScore(10);
            hitSound();

            // Create explosion particles
            for (let j = 0; j < 15; j++) {
              particles.push(new Particle(w.x, w.y, ["#0f0", "#0ff", "#ff0"][Math.floor(Math.random() * 3)]));
            }

            // Update target word if this was it
            if (targetWord && targetWord.word === w.word) {
              targetWord = null;
            }

            return false;
          }
        }
        return b.y > -50 && b.x > -50 && b.x < canvas.width + 50;
      });

      // Draw glitch effects on top (levels 10+)
      drawGlitchEffects();

      ctx.restore();

      // Level complete
      if (words.length === 0) {
        level++;
        if (level >= 20) { // Victory after completing level 20
          winGame();
          return;
        }
        spawnLevel();
      }

      animationId = requestAnimationFrame(gameLoop);
    }

    function startGame() {
      document.getElementById('startScreen').classList.add('hidden');
      level = 0;
      lives = 5;
      score = 0;
      combo = 0;
      typed = "";
      gameState = "playing";
      targetWord = null;

      // Reset glitch effect variables
      glitchTimer = 0;
      warningTimer = 0;
      currentWarning = null;
      warningDuration = 0;
      colorFlickerTimer = 0;
      scanlineOffset = 0;
      baseShakeAmount = 0;
      impactShakeTimer = 0;

      spawnLevel();
      updateHUD();
      lastFrame = performance.now();
      animationId = requestAnimationFrame(gameLoop);
    }

    function pauseGame() {
      if (gameState === "playing") {
        gameState = "paused";
        document.getElementById('pauseScreen').classList.remove('hidden');
      }
    }

    function resumeGame() {
      if (gameState === "paused") {
        gameState = "playing";
        document.getElementById('pauseScreen').classList.add('hidden');
        lastFrame = performance.now();
        animationId = requestAnimationFrame(gameLoop);
      }
    }

    function gameOver() {
      gameState = "gameOver";
      gameOverSound();
      document.getElementById('finalScore').textContent = "Final Score: " + score;
      document.getElementById('finalLevel').textContent = level + 1;
      document.getElementById('gameOverScreen').classList.remove('hidden');

      // Focus on name input
      setTimeout(() => {
        document.getElementById('gameOverNameInput').focus();
      }, 100);
    }

    function winGame() {
      gameState = "win";
      hitSound();
      setTimeout(() => hitSound(), 100);
      setTimeout(() => hitSound(), 200);
      document.getElementById('winScore').textContent = "Final Score: " + score;
      document.getElementById('winScreen').classList.remove('hidden');

      // Focus on name input
      setTimeout(() => {
        document.getElementById('winNameInput').focus();
      }, 100);
    }

    function restartGame() {
      // Hide all screens
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('winScreen').classList.add('hidden');

      // Reset everything
      words = [];
      activeBullets = [];
      particles = [];
      targetWord = null;

      startGame();
    }

    document.addEventListener("keydown", e => {
      if (e.key === "Escape") {
        if (gameState === "playing") {
          pauseGame();
        } else if (gameState === "paused") {
          resumeGame();
        }
        return;
      }

      if (gameState !== "playing") return;

      if (e.key.length === 1) {
        typed += e.key;
      } else if (e.key === "Backspace") {
        typed = typed.slice(0, -1);
      } else if (e.key === "Enter") {
        checkTyped();
        typed = "";
      }
      typedDisplay.textContent = typed;
      checkPartialMatch();
    });

    function checkTyped() {
      const index = words.findIndex(w => w.word === typed.trim());
      if (index !== -1) {
        const w = words[index];
        activeBullets.push(new Bullet(w)); // Pass entire word object for predictive aiming
        shootSound();
      }
    }

    function checkPartialMatch() {
      targetWord = null;
      for (let w of words) {
        if (w.word.startsWith(typed)) {
          typedDisplay.style.color = "#0f0";
          targetWord = w; // Set target for aiming line
          return;
        }
      }
      typedDisplay.style.color = "red";
    }

    ctx.font = "20px Courier New";

    // Initialize leaderboard on page load
    displayLeaderboard();

    // Allow Enter key to submit name in game over/win screens
    document.getElementById('gameOverNameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        saveScoreAndExit('gameOver');
      }
    });

    document.getElementById('winNameInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        saveScoreAndExit('win');
      }
    });

    // Highscore popup functions
    function showHighscores() {
      displayLeaderboard();
      document.getElementById('highscorePopup').classList.add('show');
    }

    function hideHighscores() {
      document.getElementById('highscorePopup').classList.remove('show');
    }
  </script>
</body>
</html>
